rewrite_log on;

# ####
# These paths are specified as locations because they don't need to be dynamic.  Use standard NGINX 
# whenever possible.
#

location = /robots.txt {
  set $backend "content" ;

<% if ENV['ROBOTS_TXT'] %>
  proxy_pass $scheme://$backend_hostname<%= ENV['ROBOTS_TXT'] %> ;
<% else %>
  proxy_pass $scheme://$backend_hostname/robots.txt ;
<% end %>
  add_header X-Upstream "content" always;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

}

location = / {
  set $backend "content" ;

  proxy_pass $scheme://$backend_hostname ;
  add_header X-Upstream "content" always;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

}

location ~^/server/(?P<toplevel>version)$ {
  add_header X-Upstream "version" always;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;

  return 200 "hostname: $hostname\nsites: $top_backend\nbase: <%= ENV['BUILDDATE'] %>";
}

location ~^/server/maps/(?P<map>[a-zA-Z0-9\.]+) {
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias "/etc/nginx/maps/$map" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/hosts.map$ {
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias /etc/nginx/hosts.map ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/source_ip$ {
  add_header X-Upstream "source_ip" always;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  return 200 "remote_addr: $remote_addr\nreal-ip: $realip_remote_addr\nx-forwarded-for: $http_x_forwarded_for\n" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/cloudfront_ips$ {
  add_header X-Upstream "cloudfront_ips" always ;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias /etc/nginx/cloudfront_ips.conf ;

  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

# ####
# the following test the routing lookup
#
location ~^/server/lookup/+(?P<microsite>(?P<toplevel>[a-zA-Z0-9_\.\-]+)(?P<second>/[a-zA-Z0-9_\-]+)) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $top_backend ;

  if ($micro_backend) {
    set $backend $micro_backend ;
  }

  add_header Content-Type text/plain always;
  return 200 "backend: $backend\ncachecontrol: $backend_cachecontrol\nredirect: $vanity_redirect\nhost: $host\n\n\ntoplevel: $toplevel\ntop_backend: $top_backend\nmicro_site: $microsite\nmicro_backend: $micro_backend";
}

location  ~^/+server/lookup/+(?P<toplevel>[a-zA-Z0-9_\.\-]+) {
  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $top_backend ;

  add_header Content-Type text/plain always;
  return 200 "backend: $backend\ncachecontrol: $backend_cachecontrol\nredirect: $vanity_redirect\nhost: $host\n\n\ntoplevel: $toplevel\ntop_backend: $top_backend\nmicro_site: \nmicro_backend: ";
}

# ####
# We don't want to log the healthcheck traffic
#
location = /server/healthcheck {
  add_header X-Upstream "healthcheck" always ;
  add_header Content-Type text/plain always;
  access_log off;
  return 200 "OK\n";
}

# ####
# The following two rules are for doing the default action of looking in the map file (sites.map)
# for the type of backend.  The default is WordPress if that fails.
#
location ~^/+(?P<microsite>(?P<toplevel>[a-zA-Z0-9_\.\-]+)(?P<second>/[a-zA-Z0-9_\-]+)) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $top_backend ;

  if ($micro_backend) {
    set $backend $micro_backend ;
  }

  add_header X-Lookup "input: (${toplevel}:${microsite}) backend=${backend}(${top_backend}:${micro_backend})" always ;
  # Special case of WordPress we need to figure out if wpapp or wpassets
  #
  set $is_wpfile "${backend}:$request_uri" ;
  if ($is_wpfile ~ ^wordpress:/+([a-zA-Z0-9_\-]+/)?files/ ) {
    set $backend "wpassets" ;
  }

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  #
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 $vanity_redirect ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  proxy_pass $scheme://$backend_hostname ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;
}

location  ~^/+(?P<toplevel>[a-zA-Z0-9_\.\-]+) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $top_backend ;
  
  add_header X-Lookup "input: (${toplevel}:) backend=${backend}(${top_backend}:)" always ;

  # Special case of WordPress we need to figure out if wpapp or wpassets
  #
  set $is_wpfile "${backend}:$request_uri" ;
  if ($is_wpfile ~ ^wordpress:/+([a-zA-Z0-9_\-]+/)?files/ ) {
    set $backend "wpassets" ;
  }

  add_header X-WPfile "${backend}    ${is_wpfile}" always ;

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  #
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 $vanity_redirect ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  proxy_pass $scheme://$backend_hostname ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;

}

