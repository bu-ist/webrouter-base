rewrite_log on;

# ####
# These paths are specified as locations because they don't need to be dynamic.  Use standard NGINX 
# whenever possible.
#

location = /robots.txt {
  set $toplevel "robots.txt" ;

  set $backend $host_backend ;
  set $key $hostkey; 

  if ($top_backend) {
    set $backend $top_backend ;
  }

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  #
  if ($backend = 'redirect_asis') {
    add_header X-Upstream "redirect_asis" always;
    return 302 $redirect_url ;
  }
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 "$redirect_url$request_uri" ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  # optionally override the default /robots.txt
  set $rest $request_uri ;
<% if ENV['ROBOTS_TXT'] %>
  if ($hostkey = '_') {
    set $rest <%= ENV['ROBOTS_TXT'] %> ;
  } 
<% end %>
  proxy_pass $scheme://$backend_hostname$rest ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;
}

location = / {
  set $toplevel "index.html" ;

  set $backend $host_backend ;
  set $key $hostkey ;

  if ($top_backend) {
    set $backend $top_backend ;
    set $key "$hostkey/$toplevel" ;
  }

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  #
  if ($backend = 'redirect_asis') {
    add_header X-Upstream "redirect_asis" always;
    return 302 $redirect_url ;
  }
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 "$redirect_url$request_uri" ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  proxy_pass $scheme://$backend_hostname ;

  proxy_set_header Host $backend_hostheader ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;
}

location ~^/server/(?P<toplevel>version)$ {
  add_header X-Upstream "version" always;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;

  return 200 "hostname: $hostname\nsites: $top_backend\nbase: <%= ENV['BUILDDATE'] %>";
}

location ~^/server/backend/(?P<backend>[a-z0-9\-_]+)(?P<backend_uri>/.*)$ {
  add_header Cache-Control "no-cache, no-store" always ;
  add_header X-Uri "$backend_uri" always ;
  add_header X-Backend $backend always;
  add_header X-Upstream $backend always;

  proxy_pass $scheme://$backend_hostname$backend_uri ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/config/default.d/(?P<config>[a-z0-9\-_\.]+)$ {
  add_header Cache-Control "no-cache, no-store" always ;
  add_header X-Uri "$config" always ;

  alias "/etc/nginx/default.d/$config" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/config/conf.d/(?P<config>[a-z0-9\-_\.]+)$ {
  add_header Cache-Control "no-cache, no-store" always ;
  add_header X-Uri "$config" always ;

  alias "/etc/nginx/conf.d/$config" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/maps/(?P<map>[a-zA-Z0-9\.]+) {
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias "/etc/nginx/maps/$map" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/hosts.map$ {
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias /etc/nginx/hosts.map ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/status$ {
  stub_status on;
  
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/source_ip$ {
  add_header X-Upstream "source_ip" always;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  return 200 "remote_addr: $remote_addr\nreal-ip: $realip_remote_addr\nx-forwarded-for: $http_x_forwarded_for\n" ;
 
  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

location ~^/server/cloudfront_ips$ {
  add_header X-Upstream "cloudfront_ips" always ;
  add_header Content-Type text/plain always;
  add_header Cache-Control "no-cache, no-store" always ;
  alias /etc/nginx/cloudfront_ips.conf ;

  # only from some BU networks
  allow 128.197.0.0/16 ;
  allow 168.122.0.0/16 ;
<% if ENV['ALLOW_DOCKER_NETS'] %>
  # allow the private net used by docker compose
  allow 172.0.0.0/8 ;
<% end %>

  deny all ;
}

# ####
# the following test the routing lookup
#
location ~^/server/lookup/+(?P<microsite>(?P<toplevel>[a-zA-Z0-9_\.\-]+)(?P<second>/[a-zA-Z0-9_\-]+)) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $host_backend ;
  set $key $hostkey ;

  if ($top_backend) {
    set $backend $top_backend ;
    set $key "$hostkey/$toplevel" ;
  }

  if ($micro_backend) {
    set $backend $micro_backend ;
    set $key "$hostkey/$microsite" ;
  }

  add_header Content-Type text/plain always;
  add_header X-Upstream "source_ip" always;
  add_header Cache-Control "no-cache, no-store" always ;
  return 200 "backend: $backend\ncachecontrol: $backend_cachecontrol\nredirect: $redirect_url\nscheme: $scheme\n\nhost: $host\nhostkey: $hostkey\nhost_backend: $host_backend\n\n\ntoplevel: $toplevel\ntop_backend: $top_backend\nmicro_site: $microsite\nmicro_backend: $micro_backend";
}

location  ~^/+server/lookup/+$ {
  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $host_backend ;
  set $key $hostkey ;

  add_header Content-Type text/plain always;
  add_header X-Upstream "source_ip" always;
  add_header Cache-Control "no-cache, no-store" always ;
  return 200 "backend: $backend\ncachecontrol: $backend_cachecontrol\nredirect: $redirect_url\nscheme: $scheme\n\nhost: $host\nhostkey: $hostkey\nhost_backend: $host_backend\n\n\ntoplevel: $toplevel\ntop_backend: $top_backend\nmicro_site: $microsite\nmicro_backend: $micro_backend";
}

location  ~^/+server/lookup/+(?P<toplevel>[a-zA-Z0-9_\.\-]+) {
  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $host_backend ;
  set $key $hostkey ;

  if ($top_backend) {
    set $backend $top_backend ;
    set $key "$hostkey/$toplevel" ;
  }

  add_header Content-Type text/plain always;
  add_header X-Upstream "source_ip" always;
  add_header Cache-Control "no-cache, no-store" always ;
  return 200 "backend: $backend\ncachecontrol: $backend_cachecontrol\nredirect: $redirect_url\nscheme: $scheme\n\nhost: $host\nhostkey: $hostkey\nhost_backend: $host_backend\n\n\ntoplevel: $toplevel\ntop_backend: $top_backend\nmicro_site: $microsite\nmicro_backend: $micro_backend";
}

# ####
# We don't want to log the healthcheck traffic
#
location = /server/healthcheck {
  add_header X-Upstream "healthcheck" always ;
  add_header Content-Type text/plain always;
  access_log off;
  return 200 "OK\n";
}

# ####
# The following two rules are for doing the default action of looking in the map file (sites.map)
# for the type of backend.  The default is WordPress if that fails.
#
location ~^/+(?P<microsite>(?P<toplevel>[a-zA-Z0-9_\.\-]+)(?P<second>/[a-zA-Z0-9_\-]+)) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $host_backend ;
  set $key $hostkey ;

  if ($top_backend) {
    set $backend $top_backend ;
    set $key "$hostkey/$toplevel" ;
  }

  if ($micro_backend) {
    set $backend $micro_backend ;
    set $key "$hostkey/$microsite" ;
  }

  add_header X-Lookup "input: (${toplevel}:${microsite}) backend=${backend}(${top_backend}:${micro_backend})" always ;
  # Special case of WordPress we need to figure out if wpapp or wpassets
  #
  set $is_wpfile "${backend}:$request_uri" ;
  if ($is_wpfile ~ ^wordpress:/+([a-zA-Z0-9_\-]+/)?files/ ) {
    set $backend "wpassets" ;
  }

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  if ($backend = 'redirect_asis') {
    add_header X-Upstream "redirect_asis" always;
    return 302 $redirect_url ;
  }
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 "$redirect_url$request_uri" ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  proxy_pass $scheme://$backend_hostname ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;
}

location  ~^/+(?P<toplevel>[a-zA-Z0-9_\.\-]+) {

  # The first set of variables are determining if there is a 
  # match on top or micro - output should be type
  #
  set $backend $host_backend ;
  set $key $hostkey ;

  if ($top_backend) {
    set $backend $top_backend ;
    set $key "$hostkey/$toplevel" ;
  }

  add_header X-Lookup "input: (${toplevel}:) backend=${backend}(${top_backend}:)" always ;

  # Special case of WordPress we need to figure out if wpapp or wpassets
  #
  set $is_wpfile "${backend}:$request_uri" ;
  if ($is_wpfile ~ ^wordpress:/+([a-zA-Z0-9_\-]+/)?files/ ) {
    set $backend "wpassets" ;
  }

  add_header X-WPfile "${backend}    ${is_wpfile}" always ;

  #
  # End results of above is a backend variable - next we determine 
  # what to do
  #
  if ($backend = 'redirect_asis') {
    add_header X-Upstream "redirect_asis" always;
    return 302 $redirect_url ;
  }
  if ($backend = 'redirect') {
    add_header X-Upstream "redirect" always;
    return 302 "$redirect_url$request_uri" ;
  }

  add_header X-Backend $backend always ;
  add_header X-Upstream $backend always ;

  proxy_pass $scheme://$backend_hostname ;

  if ($backend_cachecontrol) {
    add_header Cache-Control $backend_cachecontrol always ;

    # NGINX weirdness: we need to readd the other headers as matching this prevents the others
    add_header X-Backend $backend always ;
    add_header X-Upstream $backend always ;
  }

  #
  resolver <%= ENV['NAMESERVER'] %> ;

}

